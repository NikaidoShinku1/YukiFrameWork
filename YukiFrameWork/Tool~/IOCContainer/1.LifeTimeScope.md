LifeTImeScope：框架核心全局容器类，容器类的最高级别。
在Unity中新建类继承即可实现指定分支的限制作用域，使用方法如下：

```
using YukiFrameWork;
public class GameLifeTime : LifeTimeScope
{
    //可重写的Awake以及初始化容器方法
    protected override void Awake()
    {
        //这个不能去掉，否则无法执行容器的相关逻辑
        base.Awake();
    }
    
    //该方法在运行时自动执行
    protected override void InitBuilder(IContainerBuilder builder)
    {

    }
}
```
注册类型：Transient,Scope,Singleton;//分别为
瞬时实例(每次取出都是一个新对象)。
限制实例(在设定好的作用域下该分支内唯一实例，同一个作用域内不同的派生容器(分支)类能得到的实例都不相同)
全域实例: 可称为限制单例(在设定好的作用域下唯一的实例，编辑器内可选该容器所对应的作用域级别,作用域低级别容器注册的单例,任何等于或则高于该级别作用域的容器分支都可以获取到相同的实例，级别小于则无法获取实例) 

额外注意：
1.全域实例如果通过父类注册同时响应给多个派生类时，以Unity生命周期为准，先执行的类所注册的实例为该单例的访问级别,本情况下建议各个派生容器的级别都设置一致。
2.当级别设置为None时即为不指定作用域，此时默认容器级别为最高级LifeTimeScope

(注：实例注册可采用接口隔离的方式)
注册api如下：

        //简单注册
        - void Register(Type type, LifeTime lifeTime = LifeTime.Transient,params object[] args);
        - void Register(string name, Type type, LifeTime lifeTime = LifeTime.Transient, params object[] args);
        - void Register<TInstance>(LifeTime lifeTime,params object[] args) where TInstance : class;
        - void Register<TInterface, TInstance>(LifeTime lifeTime = LifeTime.Transient, params object[] args) where TInterface : class where TInstance : class;

        - void RegisterScopeInstance<TInterface, TInstance>(params object[] args) where TInterface : class where TInstance : class;
        - void RegisterScopeInstance<TInstance>(TInstance instance) where TInstance : class;       
        - void RegisterInstance<TInstance>(params object[] args) where TInstance : class;
        - void RegisterInstance<TInterface,TInstance>(params object[] args) where TInterface : class where TInstance : class;
        - void RegisterInstance<TInstance>(TInstance instance);

        //根据名称注册
        - void Register<TInstance>(string name, LifeTime lifeTime = LifeTime.Transient, params object[] args)  where TInstance : class;
        - void Register<TInterface, TInstance>(string name, LifeTime lifeTime = LifeTime.Transient, params object[] args) where TInterface : class where TInstance : class;
        - void RegisterScopeInstance<TInstance>(string name,TInstance instance) where TInstance : class;     
        - void RegisterScopeInstance<TInterface, TInstance>(string name, params object[] args) where TInterface : class where TInstance : class;    

        //注册Unity组件的方式
        - void RegisterComponent<T>(T component,bool includeInactive = false) where T : Component;
        - void RegisterComponentInScene<T>(bool includeInactive = false) where T : Component;
        - void RegisterComponentInNewPrefab<T>(GameObject gameObject, bool includeInactive = false) where T : Component;
        - void RegisterComponentInNewGameObject<T>(string name, bool includeInactive = false) where T : Component;    

容器内封装了属性Container以及GetContainer方法
调用api为：T Resolver<T>() where T : class
解析实例API如下：
        //解析组件实例
        - TComponent ResolveComponent<TComponent>(string objName,string componentName) where TComponent : Component;
        - TComponent ResolveComponent<TComponent>(string objName) where TComponent : Component;

        - object ResolveComponent(Type type, string objName, string componentName);
        - object ResolveComponent(Type type, string objName);

        //简单解析
        - T Resolve<T>() where T : class;
        - T Resolve<T>(string name) where T : class;

        - object Resolve(Type type, string name = "");

DI注入: 特性使用：Inject(自动化注入字段(属性)),InjectMethod(标记后可以使方法变成构造函数，在Mono脚本中与Awake的实现周期一致)
```
using UnityEngine;
using YukiFrameWork;
public class GameLifeTime : LifeTimeScope
{
    //可重写的Awake以及初始化容器方法
    protected override void Awake()
    {

    }
    
    //该方法在运行时自动执行
    protected override void InitBuilder(IContainerBuilder builder)
    {
        builder.RegisterScopeInstance(new B());
        builder.Register(typeof(A), LifeTime.Scoped);
    }

    public class A
    {
        [Inject]
        private B b;

        [InjectMethod]
        public void Init() => Debug.Log("Init");
    }

    public class B
    {

    }
}
```
在上述代码执行完后，A所依赖的B会自动被赋值，而A中的Init方法会被自动调用，InjectMethod可用于多参构造函数，参数的传递由容器执行

