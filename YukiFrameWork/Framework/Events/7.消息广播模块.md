消息广播模块：

在架构的使用:

``` csharp

   [RuntimeInitializeOnArchitecture(typeof(World))]
    public class EventTest : ViewController
    {   
        public enum TestEnum
        {
            One
        }
        private void Awake()
        {
            //这三个API为事件注册进架构的方式，具体的规则细则查看架构文档即可。
            this.RegisterEvent<int>(OnTest);
            this.RegisterEvent<int>("Test",OnTest);
            this.RegisterEvent<int>(TestEnum.One,OnTest);

            ///如类继承ISendEvent接口，比如系统层等，则可以使用this.SendEvent<int>(4);//this.SendEvent<int>("Test",2);等方式发送架构内注册的事件
        }

   
        private void OnTest(int v)
        {
            Debug.Log(v);
        }

        ///对于上述方式，一般认为是手动注册，通过架构方法中，对于同步的方法，当返回值为Void且唯一的继承IEventArgs这个接口的参数，可以使用自动化注册!

        public struct MyCustomArg : IEventArgs
        {
            public string name;
        }

        [RegisterEvent]//注册，以类型判断
        [StringRegisterEvent]//注册，以方法名作为事件标识，该特性具备重载，可以自由输入注册的字符串。
        [EnumRegisterEvent((int)TestEnum.One,typeof(TestEnum))]//注册，以枚举的id与枚举类型为标识。
        private void OnAutoTest(MyCustomArg arg)
        {
            //要被注册的事件，通过标记特性自动化注册后，可完全具备与手动相同的操作，直接SendEvent去发送。
        }

        //注意：这三个特性都具备unRegisterType参数，默认为UnRegisterType.Node,如果是ViewController下标记的自动事件，可以通过[RegisterEvent(UnRegisterType.Disable)]等方式进行生命周期的绑定。
    
        private void Start()
        {
            TypeEventSystem.Global.Send(5);

            //拓展方法:this.SendGlobalEvent(5);//效果如上一致
        }    
    }

```

最多可注册16个参数的全局事件中心

TypeEventSystem;//事件类型系统
基于在架构中单纯以类型作为判断条件的事件系统，架构中自带非全局模块的TypeEventSystem使用，当然全局使用是适用于任何情况
``` csharp
    public class EventTest : Monobehaviour
    {
        private void Awake()
        {
            TypeEventSystem.Global.Register<int>(OnTest).UnRegisterWaitGameObjectDestroy(this);//这里的this必须是Unity的组件,绑定后可以在该组件生命周期销毁时自动注销事件

            //拓展方法:this.AddListener<int>(OnTest);//效果如上一致
        }

        private void OnTest(int v)
        {
            Debug.Log(v);
        }
    
        private void Start()
        {
            TypeEventSystem.Global.Send(5);

            //拓展方法:this.SendGlobalEvent(5);//效果如上一致
        }    
    }
```
StringEventSystem;//字符串事件系统
基于在架构中以字符串为标记判断的事件系统
``` csharp
    public class EventTest : MonoBehaviour
    {
        private void Awake()
        {
            StringEventSystem.Global.Register<int>("Test",OnTest);

             //拓展方法:this.AddListener<int>("Test",OnTest);//效果如上一致
        }

        private void OnTest(int v)
        {
            Debug.Log(v);
        }
    
        private void Start()
        {
            StringEventSystem.Global.Send("Test",6);

             //拓展方法:this.SendStringGlobalEvent("Test",5);//效果如上一致
        }        
    }
``` 
EnumEventSystem;//枚举事件系统
基于在架构中以枚举为标记判断的事件系统
``` csharp
    public class EventTest : MonoBehaviour
    {
        public enum TestEnum
        {
            One
        }
        private void Awake()
        {
            EnumEventSystem.Global.Register<int>(TestEnum.One,OnTest);

             //拓展方法:this.AddListener<int>(TestEnum.One,OnTest);//效果如上一致
        }

        private void OnTest(int v)
        {
            Debug.Log(v);
        }
    
        private void Start()
        {
            EnumEventSystem.Global.Send(TestEnum.One,6);

            //拓展方法:this.SendEnumGlobalEvent(TestEnum.One,6);//效果如上一致
        }        
    }
``` csharp
事件系统共通的拓展API：UnRegisterWaitGameObjectDestroy<T>(T component,Action onFinish = null) where T : Component;//在注册事件后可以将全局事件绑定给指定的组件生命周期，而不需要手动销毁

Tip：拓展方法的一点私心,作者对于发布订阅的模块更倾向于监听与发送,所以拓展方法的注册API统一为AddListener,发送事件则是SendGlobalEvent,直译发送全局事件,更直观。

上述之外：框架提供一个参数使用的异步事件系统与广播


    public class EventTest : MonoBehaviour
    {
        
        public struct MyEventArg
        {
            
        }
        private void Awake()
        {   
            AsyncTypeEventSystem.Global.Register<MyEventArg>(OnTest);                   
            //拓展方法:this.AddListener_Async<MyEventArg>(OnTest);//效果如上一致

            //销毁 AsyncTypeEventSystem.Global.UnRegister<MyEventArg>(OnTest);     
        }

        private async Task OnTest(MyEventArg arg)
        {
            await Task.Run(() =>{ });
        }
    
        private void Start()
        {
            Task task = AsyncTypeEventSystem.Global.Send(new MyEventArg());
            
            //拓展方法:this.SendGlobalEvent_Async(new MyEventArg());//效果如上一致
        }        
    }

2021以上版本支持使用框架协程异步(YieldTask)的方式注册：

``` csharp

    public class EventTest : MonoBehaviour
    {   
        public struct MyEventArg
        {
            
        }
        void Awake()
        {
            AsyncTypeEventSystem_Unity.Register<MyEventArg>(OnTest);
        }

        void Start()
        {
            YieldTask task = AsyncTypeEventSystem_Unity.Send(new MyEventArg());
        }

        private async YieldTask OnTest(MyEventArg arg)
        {
            await new WaitForSeconds(5f);//IEnumerator
        }
    }

```


