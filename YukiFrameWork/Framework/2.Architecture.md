Architecture：框架核心架构,借鉴Qframework的层级思路而设置 架构层级为：IController,ISystem,IUtility,IModel

通常规则：

- ISystem、IModel 状态发生变更后通知 IController 必须用事件或BindableProperty
- IController可以获取ISystem、IModel对象来进行数据查询
- ICommand
- IQuery
- 上层可以直接获取下层，下层不能获取上层对象
- 下层向上层通信用事件
- 上层向下层通信用方法调用（只是做查询，状态变更用 Command），IController 的交互逻辑为特别情况，只能用 Command
- Controller与Command可以使用IQuery查询方法


//创建一个架构类，下面的文档演示均以该架构为标准
```
using YukiFrameWork;

public class World : Architecture<World>
{
    //架构类

    public override void OnInit()
    {
        //需要实现的初始化方法
    }
}
```

   完整API(外部的调用均通过拓展方法)：


| API      | 说明 |
| ----------- | ----------- |
| void RegisterModel<T>(T model) where T : class, IModel;    | 注册模型Model层    |
| void RegisterUtility<T>(T utility) where T : class, IUtility；    | 注册工具Utility层    |
| void RegisterSystem<T>(T system) where T : class, ISystem；    | 注册系统System层    |
| void UnRegisterModel<T>(T model = default) where T : class, IModel;    | 注销模型Model层    |
| void UnRegisterUtility<T>(T utility = default) where T : class, IUtility；    | 注销工具Utility层    |
| void UnRegisterSystem<T>(T system = default) where T : class, ISystem；    | 注销系统System层    |
| T GetModel<T>() where T : class, IModel;    | 获得Model    |
| T GetUtility<T>() where T : class, IUtility；    | 获得Utility    |
| T GetSystem<T>() where T : class, ISystem；    | 获得System    |
| IUnRegister RegisterEvent<T>(string eventName, Action<T> onEvent);    | 注册以字符串为标识的事件    |
| IUnRegister RegisterEvent<T>(Enum eventEnum, Action<T> onEvent)；    |  注册以枚举为标识的事件   |
| IUnRegister RegisterEvent<T>(Action<T> onEvent)；    | 注册以Type为标识的事件    |
| void SendEvent<T>(T t = default);    | 发送以Type为标识的事件    |
| void SendEvent<T>(string eventName, T t = default);    |  发送以字符串为标识的事件   |
| void SendEvent<T>(Enum eventEnum, T t = default);    | 发送以枚举为标识的事件    |
| void UnRegisterEvent<T>(string eventName, Action<T> onEvent);    | 注销以字符串为标识的事件    |
| void UnRegisterEvent<T>(Enum eventEnum, Action<T> onEvent)；    |  注销以枚举为标识的事件   |
| void UnRegisterEvent<T>(Action<T> onEvent)；    | 注销以Type为标识的事件    |

框架封装层级接口
| API      | 说明 |
| ----------- | ----------- |
| [IUtility](https://gitee.com/NikaidoShinku/YukiFrameWork/blob/master/YukiFrameWork/Framework/Abstract/12.IUtility.md) | 框架工具层接口 |
| [IModel](https://gitee.com/NikaidoShinku/YukiFrameWork/blob/master/YukiFrameWork/Framework/Abstract/13.IModel.md) | 框架数据层接口 |
| [ISystem](https://gitee.com/NikaidoShinku/YukiFrameWork/blob/master/YukiFrameWork/Framework/Abstract/14.IModel.md) | 框架系统层接口 |
| [ICommand](https://gitee.com/NikaidoShinku/YukiFrameWork/blob/master/YukiFrameWork/Framework/Abstract/10.Command.md) | 框架命令层接口 |
| [IQuery](https://gitee.com/NikaidoShinku/YukiFrameWork/blob/master/YukiFrameWork/Framework/Abstract/15.IQuery.md) | 框架查询层接口 |
| [IController](https://gitee.com/NikaidoShinku/YukiFrameWork/blob/master/YukiFrameWork/Framework/Abstract/16.IController.md) | 框架控制器接口 |

框架自带封装后的层级类，推荐使用，可以减少不必要的代码编写：

| Abstract class      | 说明 |
| ----------- | ----------- |
| AbstractModel | 已经封装好的模型基类 |
| AbstractSystem |已经封装好的系统基类 |
| AbstractCommand | 已经封装好的命令基类 |
| AbstractQuery<T> | 已经封装好的查询基类 |
| [ViewController](https://gitee.com/NikaidoShinku/YukiFrameWork/blob/master/YukiFrameWork/Framework/ViewController使用说明.md) | 框架提供的已经封装好的IController，可以Ctrl+Q在场景中添加ViewController然后编辑器拓展生成代码。详情可查看框架官网主页下面的ViewController的几个使用示例 文档|

封装类使用:

```

Model层:
    public class TestModel : AbstractModel
    {
        //重写的初始化方法
        public override void Init()
        {
            
        }
    }

System层:
    public class TestSystem : AbstractSystem
    {
        //重写的初始化方法
        public override void Init()
        {
            
        }
    }

Utility层:
    public class TestUtility : IUtility
    {
        //工具类什么都不做，一般用于封装API等
    }

Command层:

    public class CustomCommand : AbstractCommand
    {
        //这里执行具体的逻辑,命令默认可以发送事件
        public override void Execute()
        {
            
        }
    }

Query层:
    public class CustomQuery : AbstractQuery<int>
    {
        public override int Seek()
        {
            return 0;
        }
    }


    在架构中的使用:
    public class World : Architecture<World>
    {
        public override void OnInit()
        {
            //在初始化方法中对层级进行初始化
            this.RegisterModel(new TestModel());
            this.RegisterUtility(new TestUtility());
            this.RegisterSystem(new TestSystem());

        }       
    }

    ///正常的调用
    [RuntimeInitializeOnArchitecture(typeof(World),true)]//控制器上标记的自动化架构特性，该控制器会自动得到对应的架构
    public class CustomController : ViewController
    {
        void Start()
        {
            this.GetModel<TestModel>();

            this.RegisterEvent<EventArgs>(_ => { });

            this.GetSystem<TestSystem>();

            this.GetUtility<TestUtility>();

            this.SendCommand<CustomCommand>();

            int num = this.Query<CustomQuery>();
        }
    }

```
                

架构本体API规则接口如下：

| 规则接口使用      | 说明 |
| ----------- | ----------- |
| IGetModel | 允许对象获取模型的规则接口//架构使用---->this.GetModel |
| IGetSystem | 允许对象获取系统的规则接口//架构使用---->this.GetSystem |
| IGetUtility | 允许对象获取工具层的规则接口//架构使用---->this.GetUtility |
| IGetRegisterEvent | 允许对象注册事件的规则接口//架构使用---->this.RegisterEvent |
| ISendEvent| 允许对象发送事件//架构使用---->this.SendEvent |
| ISendCommand | 允许对象发送命令//架构使用---->this.SendCommand |
| IGetQuery| 允许对象封装查询发送//架构使用---->this.Query |


- 一般情况下的使用:

注意:所有新建的架构类，运行时会自动添加好所有的全局架构(在ViewController上方中标记特性RuntimeInitializeOnArchitecture特性时，当IsGeneric参数为true时表示该控制器可以使用架构),全局架构的初始化时机在场景加载、所有对象的Awake之前。




