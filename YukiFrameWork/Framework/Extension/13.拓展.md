协程拓展支持：IAsyncExtensionCore
```
public class TestScripts : MonoBehaviour
{
    private void Start()
    {
        //对协程的启动(不绑定该Mono的生命周期，即使该脚本销毁依然执行该协程)
        var core = Enumerator().Start();
        //暂停协程
        core.OnPause();
        //该方法的无参版本返回值为迭代器，可以用于在协程中进行yield return该方法,等待当前拓展协程完全执行完毕后执行
        core.OnExecuteAsync();
        //该方法传入事件后即默认异步，无需在外部等待,当该协程执行完毕则会调用该事件
        core.OnExecuteAsync(() => { });
        //绑定生命周期(因拓展协程不受到生命周期影响,所以当需要时应进行绑定)
        core.CancelWaitGameObjectDestory(this);
        //恢复协程(仅暂停后该方法才有效果)
        core.OnResume();           
    }

    public IEnumerator Enumerator()
    {
        yield return new WaitForSeconds(2);
        Debug.Log("定时两秒");
    }

}
```
反射拓展支持：GlobalReflectionSystem(谨慎使用，性能开销过大)

该拓展对所有的类型通用,可以强制反射调用方法(不支持重载，返回第一个方法)，以及反射获取字段并赋值具体示例如下：
```
public class TestScripts : MonoBehaviour
{
    private void Start()
    {
        //获得这个类的对象
        NewClass c = new NewClass();    
        //获得字段value
        float value = c.GetValue("value",ValueType type = ValueType.Field);
        //获得属性Value
        float Value = c.GetValue("Value",ValueType type = ValueType.Property);

        //赋值操作
        c.SetValue("value",10,ValueType type = ValueType.Field)

        //强制调用方法必须要给方法打上动态标记DynamicMethod:
        c.InvokeMethod("Test");
    }

    public class NewClass
    {
        private float value;
        public float Value { get; private set; }

        [DynamicMethod]
        private void Test()
        {
            Debug.Log("Test");
        }
    }
   

}
```