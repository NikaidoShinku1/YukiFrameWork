协程拓展支持：IYieldExtension 
标注：[框架支持对于协程的异步流转换，使用标准await/async启动协程，看完该文档拓展协程以及协程性能工具的介绍后进入链接](https://gitee.com/NikaidoShinku/YukiFrameWork/blob/master/YukiFrameWork/Framework/Extension/14.异步拓展.md)

```
public class TestScripts : MonoBehaviour
{
    private void Start()
    {
        //对协程的启动(不绑定该Mono的生命周期，即使该脚本销毁依然执行该协程)
        var core = Enumerator().Start();
        //暂停协程
        core.OnPause();
        //该属性用于在协程中进行yield return,等待当前拓展协程完全执行完毕后执行
        //yield core.Request;
        //该方法传入事件后即默认异步，无需在外部等待,当该协程执行完毕则会调用该事件
        core.Request(() => { });
        //绑定生命周期(因拓展协程不受到生命周期影响,所以当需要时应进行绑定)
        core.CancelWaitGameObjectDestory(this);
        //恢复协程(仅暂停后该方法才有效果)
        core.OnResume();           
        //对协程强行进行终止:
        core.Cancel();

        //如果只是想启动普通协程(返回值为Coroutine)则使用:
        Coroutine coroutine = MonoHelper.Start(Enumerator());
        //对普通协程进行关闭:
        MonoHelper.Stop(coroutine);
    }

    public IEnumerator Enumerator()
    {
        yield return new WaitForSeconds(2);
        Debug.Log("定时两秒");
    }

}
```

协程的性能拓展工具CoroutineTool:

IEnumerator static API:

    //对UnityEngine.WaitForFixedUpdate的封装，缓存对象不会一直产生消耗
    - WaitForFixedUpdate WaitForFixedUpdate()

    //对UnityEngine.WaitForEndOfFrame的封装，缓存对象不会一直产生消耗
    - WaitForEndOfFrame WaitForEndOfFrame();

    //GC开销大幅度减少的WaitForSecondsRealtime(不受Time.timeScale影响的定时)
    - IEnumerator WaitForSecondsRealtime(float time);
    
    //GC开销大幅度减少的WaitForSeconds
    - IEnumerator WaitForSeconds(float time);
    
    //等待设置的帧数值
    - IEnumerator WaitForFrames(int count = 1);
    
    //等待一帧
    - IEnumerator WaitForFrame();
    
    //GC开销大幅度减少的WaitUntil(效果与yield return new WaitUntil(Func<bool> m_Predicate)相同)
    - IEnumerator WaitUntil(Func<bool> m_Predicate)
    
    //GC开销大幅度减少的WaitWhile(效果与yield return new WaitWhile(Func<bool> m_Predicate)相同)
    - IEnumerator WaitWhile(Func<bool> m_Predicate)

```

public class TestScripts : MonoBehaviour
{
    IEnumerator Start()
    {
        yield return CoroutineTool.WaitForSeconds(3);
        
    }
}

```

场景管理工具SceneTool：

static API:

    ///对SceneManager的同步加载多做一层封装
    - void LoadScene(string sceneName,LoadSceneMode mode = LoadSceneMode.Single);
    - void LoadScene(int sceneIndex,LoadSceneMode mode = LoadSceneMode.Single)
    - void LoadScene(string sceneName, LoadSceneParameters sceneParameters)
    - void LoadScene(int sceneIndex, LoadSceneParameters sceneParameters);

    - XFABManagerSceneTool XFABManager;//联合XFABManager的异步加载场景的拓展

    ///对异步加载的封装:
    //场景的异步加载，返回拓展协程接口，可以传入进度监听回调
    IYieldExtension LoadSceneAsync(string sceneName,Action<float> loadingCallBack = null, LoadSceneMode mode = LoadSceneMode.Single);
    IYieldExtension LoadSceneAsync(int sceneIndex, Action<float> loadingCallBack = null, LoadSceneMode mode = LoadSceneMode.Single)；

    //不立刻切换场景的异步加载API：
    //一定要手动传onCompleted的逻辑，否则场景不会自动切换
    IYieldExtension LoadSceneAsyncWithAllowSceneActive(string sceneName,Action<AsyncOperation> onCompleted, Action<float> loadingCallBack = null, LoadSceneMode mode = LoadSceneMode.Single)；
    IYieldExtension LoadSceneAsyncWithAllowSceneActive(int sceneIndex, Action<AsyncOperation> onCompleted, Action<float> loadingCallBack = null, LoadSceneMode mode = LoadSceneMode.Single)

    //场景工具全局的事件支持:

    //全局的监听场景加载的事件，只要有场景在异步就会触发
    event Action<float> LoadingScene = null;
    //全局的监听场景加载完成的事件，只要有场景在异步就会触发
    event Action LoadSceneSucceed = null;

```

public class TestScripts : MonoBehaviour
{
    void Start()
    {
        //示例:
        SceneTool.LoadScene("new Scene");

        SceneTool.LoadSceneAsyncWithAllowSceneActive("new Scene",operation => operation.allowSceneActivation = true,progress => Debug.Log("当前的进度" + progress));

        //如果场景是通过XFABManager打包AssetBundle的，示例如下:

        SceneTool.XFABManager.LoadScene("new Scene");
        SceneTool.XFABManager.LoadSceneAsyncWithAllowSceneActive("new Scene",operation => operation.allowSceneActivation = true,progress => Debug.Log("当前的进度" + progress));

    }
}


```

Unity API拓展支持:

```

public class TestScripts : MonoBehaviour
{
    void Start()
    {                
        /// OnTriggerEnter --- this.BindTriggerEnterEvent(other => { });
        /// OnTriggerStay --- this.BindTriggerStayEvent(other => { });
        /// OnTriggerExit --- this.BindTriggerExitEvent(other => { });
        /// OnTriggerEnter2D --- this.BindTriggerEnter2DEvent(collider2D => { });
        /// OnTriggerExit2D --- this.BindTriggerExit2DEvent(collider2D => { });
        /// OnTriggerStay2D --- this.BindTriggerStay2DEvent(collider2D => { });
        /// OnCollisionEnter ---  this.BindCollisionEnterEvent(collision => { });
        /// OnCollisionStay ---  this.BindCollisionStayEvent(collision => { });
        /// OnCollisionExit ---  this.BindCollisionExitEvent(collision => { });
        /// OnCollisionEnter2D ---  this.BindCollisionEnter2DEvent(collision => { });
        /// OnCollisionStay2D --- this.BindCollisionStay2DEvent(collision2D => { });
        /// OnCollisionExit2D --- this.BindCollisionExit2DEvent(collision2D => { });
        /// OnMouseDown --- this.BindMouseDownEvent(() => { });
        /// OnMouseUp --- this.BindMouseUpEvent(() => { });
        /// OnMouseEnter --- this.BindMouseEnterEvent(() => { });
        /// OnMouseExit --- this.BindMouseExitEvent(() => { });
        /// OnMouseDrag --- this.BindMouseDragEvent(() => { });


        //UI事件拓展支持:
        //示例: 
        Image image = GetComponent<Image>();

        //IBeginDragHandler --- image.BindBeginDragEvent(eventData => { });
        //IDragHandler --- image.BindDragEvent(eventData => { });
        //IEndDragHandler --- image.BindEndDragEvent(eventData => { });
        //IInitializePotentialDragHandler --- image.BindInitializePotentialDragEvent(eventData => { });
        //IPointerClickHandler --- image.BindPointerClickEvent(eventData => { });
        //IPointerDownHandler --- image.BindPointerDownEvent(eventData => { });
        //IPointerEnterHandler --- image.BindPointerEnterEvent(eventData => { });
        //IPointerUpHandler --- image.BindPointerUpEvent(eventData => { });
        //IPointerExitHandler --- image.BindPointerExitEvent(eventData => { });
        //IScrollHandler --- image.BindScrollEvent(eventData => { });
        //ISelectHandler --- image.BindSelectEvent(eventData => { });
        //ISubmitHandler --- image.BindSubmitEvent(eventData => { });
        //IDropHandler --- image.BindDropEvent(eventData => { });
        //IDeselectHandler --- image.BindDeselectEvent(eventData => { });
        //IUpdateSelectedHandler --- image.BindUpdateSelectedEvent(eventData => { });
        //ICancelHandler --- image.BindCancelEvent(eventData => { });
        //IMoveHandler --- image.BindMoveEvent(eventData => { });

       //对GameObject的封装拓展支持:
        GameObject obj = new GameObject();
        //可以更加方便的调用Unity的原本的API，通过链式编程的方式一次性搞定
        obj.SetName("新的obj").Tag("设置标签").Layer(0).SetPosition(Vector3.one).SetLocalScale(Vector3.one).DonDestroyOnLoad().GetOrAddComponent<Image>();
    }
}

///对MonoBehaviour的Update做的拓展处理:(在不使用ActionKit或者没有额外操作例如给Update设置条件参数的情况下建议使用该拓展)

public class TestScripts : MonoBehaviour
{
    void Start()
    {   
         Action<MonoHelper> onEvent = helper => { };
         ///可以在任意脚本下注册事件到MonoHelper的Update拓展中
         MonoHelper.Update_AddListener(onEvent);
         MonoHelper.FixedUpdate_AddListener(onEvent);
         MonoHelper.LateUpdate_AddListener(onEvent);
    }
}


```
在编辑器中添加MonoHelper:
![输入图片说明](Texture/1.png)
![输入图片说明](Texture/2.png)

可以在编辑器下添加事件进行update的托管,不需要可视化则不添加,注意在任何情况下，MonoHelper最多只能存在一个!

反射拓展支持：GlobalReflectionSystem(谨慎使用，性能开销过大)

该拓展对所有的类型通用,可以强制反射调用方法(不支持重载，返回第一个方法)，以及反射获取字段并赋值具体示例如下：
```
public class TestScripts : MonoBehaviour
{
    private void Start()
    {
        //获得这个类的对象
        NewClass c = new NewClass();    
        //获得value
        float value = c.GetValue("value");
        //获得属性Value
        float Value = c.GetValue("Value");

        //赋值操作 注意:如果赋值的是属性，必须要持有Setter!
        c.SetValue("value",10)
      
        c.InvokeMethod("Test");
    }

    public class NewClass
    {
        private float value;
        public float Value { get; private set; }
    
        private void Test()
        {
            Debug.Log("Test");
        }
    }
   

}
```