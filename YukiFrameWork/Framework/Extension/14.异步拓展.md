协程异步语法转换(该拓展禁止使用一切C# .Net自带Task的所有多线程原生API)

```
public class TestScripts : MonoBehaviour
{
    private void Start()
    {
        CallBackAsync();
        
    }

    private async void CallBackAsync()
    {
        //对于协程，可以直接进行标记,即使不标记ToSingleTask也可以直接进行判定(框架已支持)
        await Enumerator().ToSingleTask();
        Debug.Log("定时两秒的协程结束了");  
        
        var obj = await GetObjAsync();    

        Debug.Log("过了五秒后得到了这个obj:" + obj.Result);
    }

    private async Task<GameObject>  GetObjAsync()
    {
        GameObject cube = new GameObject();
        await new WaitForSeconds(5f);//可以直接同步协程的所有等待API
    }

    public IEnumerator Enumerator()
    {
        yield return new WaitForSeconds(2);
        Debug.Log("定时两秒");

    }

    private IEnumerator DefaultEnumerator()
    {
        //可以将Task转换为迭代器等待，注意:使用协程进行转换必须检查代码，迭代器如果直接标记Task实例会出现卡死的情况
        yield return CoroutineConvertAsync().ToCoroutine();
    }
    //返回值是框架提供的YieldTask，支持有参数的返回
    private async YieldTask CoroutineConvertAsync()
    {
        //协程性能工具等待一帧的api
        await CoroutineTool.WaitForFrame();        
    }

    private async void InitAsset()
    {
        //对于资源的加载，也有特殊的拓展,直接异步出值
        UnityEngine.Object asset = await Resources.LoadAsync<GameObject>("");

        AsyncOperation operation = await SceneManager.LoadSceneAsync("");

        //假设有一个AssetBundle
        AssetBundle assetBundle = null;
        UnityEngine.Object asset = await assetBundle.LoadAssetAsync("");
    }
}
```

异步拓展的注意事项：为等待器绑定生命周期时，如果绑定的组件在执行到这个等待之前就已经被销毁了，那么等来到该逻辑时就会强行终止
