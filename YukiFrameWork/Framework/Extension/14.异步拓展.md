协程异步语法转换(该拓展禁止使用一切C# .Net自带Task的所有多线程原生API)

Unity 2021以上版本可以使用YieldTask框架提供任务类做异步返回值


``` csharp
public class TestScripts : MonoBehaviour
{
    private void Start()
    {
        CallBackAsync();
        
    }

    private async void CallBackAsync()
    {
        //对于协程，可以直接进行标记,即使不标记ToSingleTask也可以直接进行判定(框架已支持)
        await Enumerator().ToSingleTask();
        Debug.Log("定时两秒的协程结束了");  
        
        var obj = await GetObjAsync();    

        Debug.Log("过了五秒后得到了这个obj:" + obj.Result);
    }

    private async YieldTaskTask<GameObject>  GetObjAsync()
    {
        GameObject cube = new GameObject();
        await new WaitForSeconds(5f);//可以直接同步协程的所有等待API
    }

    public IEnumerator Enumerator()
    {
        yield return new WaitForSeconds(2);
        Debug.Log("定时两秒");

    }

    private IEnumerator DefaultEnumerator()
    {
        //可以将Task转换为迭代器等待，注意:使用协程进行转换必须检查代码，迭代器如果直接标记Task实例会出现卡死的情况
        yield return CoroutineConvertAsync().ToCoroutine();
    }
    //返回值是框架提供的YieldTask，支持有参数的返回
    private async YieldTask CoroutineConvertAsync()
    {
        //协程性能工具等待一帧的api
        await CoroutineTool.WaitForFrame();        
    }

    private async void InitAsset()
    {
        //对于资源的加载，也有特殊的拓展,直接异步出值
        UnityEngine.Object asset = await Resources.LoadAsync<GameObject>("");

        AsyncOperation operation = await SceneManager.LoadSceneAsync("");

        //假设有一个AssetBundle 
        AssetBundle assetBundle = null;
        UnityEngine.Object asset = await assetBundle.LoadAssetAsync("").CancelWaitGameObjectDestroy(this);

        //CancelWaitGameObjectDestroy绑定生命周期，当该异步需要再某个对象销毁时终止，可以使用。

        await CoroutineTool.WaitForFrame().CancelWaitGameObjectDestroy(this);

        //对于异步的操作。框架的导入将全面覆盖所有的Unity提供的异步API以及迭代器，均可通过await 直接异步。也可以使用如下操作:

        await YieldTask.Run(() => new WaitForSeconds(5f)).CancelWaitGameObjectDestroy(this);

        //当希望多个任务进行生命周期绑定时可以使用

        YieldTask[] tasks = new YieldTask[5];

        //在tasks添加对应的任务。添加通过YieldTask.Run即可。不建议自己new
        await YieldTask.WhenAll(tasks).CancelWaitGameObjectDestroy(this);;

        await YieldTask.WhenAny(tasks).CancelWaitGameObjectDestroy(this);

        
    }
}
```

异步拓展的注意事项：为等待器绑定生命周期时，如果绑定的组件在执行到这个等待之前就已经被销毁了，那么等来到该逻辑时就会强行终止
