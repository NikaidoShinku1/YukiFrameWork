协程异步语法转换(该拓展禁止使用一切C# .Net自带Task的所有多线程原生API)

static API:

    - YieldAwaitable ToSingleTask(this IYieldExtension extension);//拓展方法传入拓展协程本体，返回框架协程等待器

    - YieldAwaitable ToSingleTask(this IEnumerator enumerator);//拓展方法传入协程本体，返回框架协程等待器

    - YieldAwaitable ToSingleTask<T>(this T instruction) where T : YieldInstruction //对于Unity官方YieldInstruction类，也可以使用转换

    - IEnumerator ToCoroutine(this Task task)；//将Task类转换为协程(内部的等待必须是框架提供API或者协程的转换)

    - IEnumerator ToCoroutine<T>(this Task<T> task)//如上

    //默认情况下，使用该语法启动的协程不受到生命周期的影响，可以使用这个API对等待器进行生命周期绑定;
    - YieldAwaitable CancelWaitGameObjectDestroy<T>(this YieldAwaitable awaitable, T component) where T : Component；

    //如果await后面跟着的是迭代器(框架支持直接位于等待器中标记迭代器),则可以用该方法绑定生命周期
    - YieldAwaitable CancelWaitGameObjectDestroy<T>(this IEnumerator enumerator, T component) where T : Component

     //如果await后面跟着的是Unity官方的YieidInstruction(框架支持直接位于等待器中标记YieidInstruction),则可以用该方法绑定生命周期
    - YieldAwaitable CancelWaitGameObjectDestroy<T>(this YieldInstruction enumerator, T component) where T : Component

```
public class TestScripts : MonoBehaviour
{
    private void Start()
    {
        CallBackAsync();
        
    }

    private async void CallBackAsync()
    {
        //对于协程，可以直接进行标记,即使不标记ToSingleTask也可以直接进行判定(框架已支持)
        await Enumerator().ToSingleTask();
        Debug.Log("定时两秒的协程结束了");  
        
        var obj = await GetObjAsync();    

        Debug.Log("过了五秒后得到了这个obj:" + obj.Result);
    }

    private async Task<GameObject>  GetObjAsync()
    {
        GameObject cube = new GameObject();
        await new WaitForSeconds(5f);//可以直接同步协程的所有等待API
    }

    public IEnumerator Enumerator()
    {
        yield return new WaitForSeconds(2);
        Debug.Log("定时两秒");

    }

    private IEnumerator DefaultEnumerator()
    {
        //可以将Task转换为迭代器等待，注意:使用协程进行转换必须检查代码，迭代器如果直接标记Task实例会出现卡死的情况
        yield return CoroutineConvertAsync().ToCoroutine();
    }

    private async Task CoroutineConvertAsync()
    {
        //协程性能工具等待一帧的api
        await CoroutineTool.WaitForFrame();        
    }

}
```

异步拓展的注意事项：为等待器绑定生命周期时，如果绑定的组件在执行到这个等待之前就已经被销毁了，那么等来到该逻辑时就会强行终止
